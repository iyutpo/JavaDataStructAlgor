package DynamicProgramming;

/*
* Dynamic Programming Algorithm:
*  基本思想：是将一个复杂的问题分解为小问题进行解决，从而一步步获取最优解的处理算法。虽然DP与D&C很类似，但是二者的区别在于，适用于DP求解的问题，
*          经过分解后，分解得到的子问题往往不是相互独立的。多个阶段的子问题之间的联系通常是解决DP问题的关键，这种联系也叫 转移方程
*          DP问题通常可以通过填表的方式来逐步递推，从而得到最优解。
*  动态规划问题有很多应用案例：
*   1. 0-1背包问题：有一个背包，容量为4磅，现有如下物品：
*       +--------+--------+--------+
*       |  物品   |   重量  |  容量  |
*       +--------+--------+--------+
*       | 吉他(G) |    1   |  1500  |
*       +--------+--------+--------+
*       | 音响(S) |    4   |  3000  |
*       +--------+--------+--------+
*       | 电脑(L) |    3   |  2000  |
*       +--------+--------+--------+
*      要求：达到的目标为装入的背包的总价值最大，并且重量不超出；装入的物品不能重复
*      思路分析和图解：利用DP来解决，每次遍历到第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中，即对于给定的n个物品，我们令v[i]和w[i]
*                   分别是第i个物品的价值和重量，C为背包的容量，再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值，则有下面的结果：
*               (1). v[i][0] = v[0][j] = 0
*               (2). 当w[i] > j 时， v[i][j] = v[i-1][j]
*               (3). 当 j >= w[i] 时， v[i][j] = max( v[i-1][j], v[i-1][j-w[i]] + v[i] )
*      根据上面的步骤我们可以列出下面的表格：
*       +--------+--------+--------+--------+--------+---------+
*       |  物品   |   0磅  |   1磅  |   2磅   |   3磅  |   4磅    |
*       +--------+--------+--------+--------+--------+---------+
*       |  NULL  |    0   |    0   |    0   |    0   |    0    |
*       +--------+--------+--------+--------+--------+---------+
*       | 吉他(G) |    0   | 1500(G)| 1500(G)| 1500(G)| 1500(G) |
*       +--------+--------+--------+--------+--------+---------+
*       | 音响(S) |    0   | 1500(G)| 1500(G)| 1500(G)| 3000(S) |
*       +--------+--------+--------+--------+--------+---------+
*       | 电脑(L) |    0   | 1500(G)| 1500(G)| 2000(L)|3500(G,L)|
*       +--------+--------+--------+--------+--------+---------+
*       结合上面的表格再来看上面的三个步骤，我们分别来解释一下：
*               (1). v[i][0] = v[0][j] = 0                  // 表示 当不放入物品，或者背包重量限制为0磅时，总价值为0
*               (2). 当w[i] > j 时， v[i][j] = v[i-1][j]     // 当 要加入的新增商品的容量大于当前背包的容量时，就直接使用上一个单元格的值
*               (3). 当 j >= w[i] 时， v[i][j] = max( v[i-1][j], v[i-1][j-w[i]] + v[i] )   // 当 要加入的新增商品的容量小于等于
*                       当前背包的容量时，我们从 “上一个单元格” 和 “当前商品价值+剩余空间所对应的最大价值” 之间 取最大值：
*                           v[i-1][j]：是上一个单元格装入的最大值
*                           v[i]：表示当前商品的价值
*                           v[i-1][j-w[i]]: 表示装入 i-1 商品，到剩余空间 j-w[i]的最大值 （即上表最右下角的例子）
* 下面来看一下 0-1背包问题的代码实现：
* */
public class DynamicProgramming {

    public static void main(String[] args) {
        int[] w = {1, 4, 3};
        int[] val = {1500, 3000, 2000};
        int C = 4;          // 背包容量
        int n = val.length;
        int[][] v = new int[n+1][C+1];

        // 进行(1)，当不放入物品，或者背包重量限制为0磅时，总价值为0
        for (int i = 0; i < v.length; i++) {
            v[i][0] = 0;
        }
        for (int j = 0; j < v[0].length; j++) {
            v[0][j] = 0;
        }

        // 下面开始用 DP 来fill 矩阵v：
        for (int i = 1; i < v.length; i++) {
            for (int j = 1; j < v[0].length; j++) {
                if (w[i-1] > j) {   // 这里 i-1 是因为我们的 i 是从 1 开始的
                    v[i][j] = v[i-1][j];
                } else {
                     v[i][j] = Math.max(v[i-1][j], v[i-1][j-w[i-1]] + val[i-1]);   // 这里 val[i-1]也是因为 i是从1 开始索引的
                }
            }
        }
        System.out.println("Maximum possible value is： " + v[n][C]);
    }
}

























